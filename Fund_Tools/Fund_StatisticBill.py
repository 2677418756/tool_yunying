
# 本次计费表只针对抖音和快手，并且还需要根据输入的系数来决定给资金方的分配


# -*- coding: utf-8 -*-
"""
Created on Thu Oct  6 18:18:12 2022

@author: Wind_Aleady_Here
"""

import pandas as pd
import datetime
import os
from collections import Counter

# 本金计费表的业务逻辑

"""
需要的数据来源：上一次本金计费表、本次的订单回款表
业务逻辑：读取

核心解决的的问题：
待解决的问题：
备注：
"""


def str_to_date(str_):
    # 【日期类型转换】让数据从str型转换成date型
    date_p = datetime.datetime.strptime(str_, '%Y-%m-%d').date()
    return date_p


def date_to_str(date_):
    # 【日期类型转换】让数据从date型转换成str型
    return str(date_)


def timestamp_to_date(timestamp_):
    date = timestamp_.to_pydatetime().date()
    return date


def one_decimal(x_data):
    # 【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.1f' % x_data  # 变成字符串来保留一位小数了
    return float(x_str)


def two_decimal(x_data):
    # 【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.2f' % x_data  # 变成字符串来保留一位小数了
    return float(x_str)


class AutoExtractFiles():

    def __init__(self, 文件夹路径, 需打开表格名列表):
        # 实例变量初始化
        self.输出字典 = {}
        self.文件夹路径 = 文件夹路径
        self.需打开表格名列表 = 需打开表格名列表

    def handle(self):

        所有文件名列表 = os.listdir(self.文件夹路径)
        计数满足 = len(self.需打开表格名列表)

        for file in 所有文件名列表:
            # 判断列表中元素是否存在，若存在则打开
            文件名前缀 = os.path.splitext(file)[0]
            表格类型 = 文件名前缀.split('-')[2]  # FOLA旗舰店-抖音-订单表-CJY-无备注.xlsx
            for need_workbook in self.需打开表格名列表:
                if 表格类型 == need_workbook:
                    # 记录需打开的文件名，最后返回
                    计数满足 = 计数满足 - 1  # 若所需文件全部都存在，则最后计数为0
                    temp = self.文件夹路径 + '\\' + file
                    self.输出字典[表格类型] = temp

        return self.输出字典


def 本金计费表(上次本金计费表, 账单回款, 当天自然日字符串,回款节奏系数):

    当天自然日 = datetime.datetime.strptime(当天自然日字符串, '%Y-%m-%d').date()

    try:
        上次本金计费表['订单创建日期'] = 上次本金计费表['订单创建日期'].map(timestamp_to_date)
    except:
        pass
    上次本金计费表['支付日期'] = 上次本金计费表['支付日期'].map(timestamp_to_date)

    try:
        上次本金计费表['理论结算日期'] = 上次本金计费表['理论结算日期'].map(timestamp_to_date)
    except(AttributeError):
        #若没有已结算场次，则可能跳转到此语句
        pass
    账单回款明细表 = 账单回款.copy()
    账单回款明细表['订单创建日期'] = 账单回款明细表['订单创建日期'].map(str_to_date)

    # 创建空白dataframe
    服务商账单核对表 = pd.DataFrame()

    当天正常结算场次包裹型列表 = []  # 希望可以[{'a':1},{'a':2},{'a':3}]同一KEY不同VALUE，直接拆列表来访问

    未结算上次本金计费表 = 上次本金计费表[(上次本金计费表['是否结算'] == '否')]
    list_ = list(未结算上次本金计费表['订单创建日期'])

    # 返回字典，统计列表中值出现的次数，可统计重复值，Key为原列表中的values
    未结算剩余金额字典 = Counter(list_)

    for k, v in 未结算剩余金额字典.items():
        """
        按场次进行大循环，场次内的记录条数做小循环
        """
        未结算条数 = v
        场次日期 = k

        temp_dataframe0 = 未结算上次本金计费表[(未结算上次本金计费表['订单创建日期'] == 场次日期)]
        # 下面两个本质是各自表中唯一的series
        temp_dataframe2 = 账单回款明细表[(账单回款明细表['订单创建日期'] == 场次日期)]

        # 【判断正确日期】如果当天自然日 - 场次日期 只计算大于1的自然日
        # 计算时间差距的
        temp_time = 当天自然日 - 场次日期
        天数 = temp_time.days + 1
        if 天数 <= 1:
            # 从第二天开始提取总金额 - 退 - 回 - 特殊
            print('需异常报错：输入当天自然日小于某场次日期')
            # ——————————————————————————————————————————————————————————————————读取数据模块

        try:
            场次本金回款金额 = temp_dataframe2.iloc[0].at[f'第{天数 - 1}天']
        except(IndexError):
            场次本金回款金额 = 0.00

        # 让数据保留一位小数，且自动四舍五入
        场次本金回款金额 = two_decimal(场次本金回款金额 * 回款节奏系数)
        # ——————————————————————————————————————————————————————————————————读取数据模块

        授信代码最小值 = temp_dataframe0['授信代码'].min()  # min()返回series中的最小值,也就是返回授信代码这一列
        是否计算完毕 = True  # 这里的逻辑可以理解为 相信第一次就能计算完毕，所以填True
        中间值记录 = 0.00

        # 条数退货退款金额 = 场次退货退款金额
        条数本金回款金额 = 场次本金回款金额
        while 未结算条数 >= 1:
            当天正常结算场次字典 = {}
            # 【每一个while条数，只有改变的同场异次，循环写入一次】写账单明细表
            明细字典2 = {}

            # 提取单独一条需要的记录，来提取数字
            final_dataframe1 = 未结算上次本金计费表[
                (未结算上次本金计费表['订单创建日期'] == 场次日期) & (未结算上次本金计费表['授信代码'] == 授信代码最小值)]
            本次应统计金额 = final_dataframe1.iloc[0].at[f'第{天数}天']
            上次已统计金额 = final_dataframe1.iloc[0].at[f'第{天数 - 1}天']
            # 【判断本次应统计金额需填入】本次应统计金额应该为0，也就是需要统计才对
            if not (本次应统计金额 == 0 and 上次已统计金额 != 0):
                print('异常警告：本次应统计金额或者上次已统计金额')

            # 【将同场次下，没有改变总计的条数进行判断，并写入与跳过】
            if 未结算条数 != v and 是否计算完毕 == True:
                # 未结算条数 != v 代表不是第一条记录，且计算完毕，所以上次总计等于本次总计
                print('同场其余未结算场次：', 场次日期, 授信代码最小值)
                上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码最小值]) & 上次本金计费表['订单创建日期'].isin(
                    [场次日期]), f'第{天数}天'] = 上次已统计金额
                授信代码最小值 = 授信代码最小值 + 1
                未结算条数 = 未结算条数 - 1
                continue  # 因为后面条数的本次应统计金额等于上次已统计金额，所以不用继续后面循环执行语句

            # 【判断：选择总计的方法】
            if 是否计算完毕 == False:  # 回款还没扣完需要下一条记录
                本次总计 = 上次已统计金额 - 中间值记录
            elif 是否计算完毕 == True:  # 相信回款扣的完 或者 回款扣完了（已经在前面解决）
                # 第一次循环先走本条语句，因为前面设置为True了
                本次总计 = 上次已统计金额 - 场次本金回款金额
            # 让数据保留一位小数，且自动四舍五入
            本次总计 = two_decimal(本次总计)

            # 【判断：本条是否计算完毕】
            if 本次总计 <= 0.00:
                # 若本次会结算，则本次总计填0，是否结算填是，账单表的值考虑改变
                # 【判断后写入是否结算】写入要用上次本金计费表，因为输出的也是上次本金计费表
                上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码最小值]) & 上次本金计费表['订单创建日期'].isin(
                    [场次日期]), '是否结算'] = '是'  # 某条记录结算
                上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码最小值]) & 上次本金计费表['订单创建日期'].isin(
                    [场次日期]), '结算方式'] = '正常结算'
                当天正常结算场次字典[场次日期] = 授信代码最小值
                当天正常结算场次包裹型列表.append(当天正常结算场次字典)
                当天正常结算场次字典 = {}
                # 11.5临时加
                是否结算 = '是'
                # 影响多少用中间值记录
                中间值记录 = abs(本次总计)
                是否计算完毕 = False
                本次总计 = 0.00
                """
                11.6日记载 上次条数本金回款金额 用于此情况： 假设三条同场次的记录一次性结算两个 
                此时 ①的条数回款 = ①的统计 用于全部扣减 所以 ①扣完后剩余 = 总场次回款 - ①的统计 ①扣完后剩余用中间值记录
                ②的条数回款 = ②的统计 用于全部扣减 所以 ②扣完后剩余 = ①扣完后剩余 - ②的统计 ②扣完后剩余用中间值记录
                最后 ③的条数回款 = ②扣完后剩余
                """
                # 只要是回款本条无法扣完，本条付出的都是上次已统计
                条数本金回款金额 = 上次已统计金额


            elif 本次总计 > 0.00:
                # 本条的确够扣完了，现在要看下本条是第一条还是最后一条，如果是第一条则 无中间值记录 直接场次回款是多少就是多少 ，如果是最后一条 就用上次扣完后剩余回款
                if 是否计算完毕 == False:  # 本条是最后一条
                    # 中间有过结算条数的后一条，把上次剩余留下
                    条数本金回款金额 = 中间值记录  # 11.5更改
                elif 是否计算完毕 == True:  # 本条是第一条 （注：为了结构完善才加入elif）
                    条数本金回款金额 = 场次本金回款金额
                中间值记录 = 0.00
                是否计算完毕 = True
                是否结算 = '否'

            # ——————提取其他相关信息
            服务方1 = final_dataframe1.iloc[0].at['服务方']
            资金方式1 = final_dataframe1.iloc[0].at['资金方式']
            授信代码1 = 授信代码最小值
            是否结算 = 是否结算
            # ——————提取其他相关信息

            # 1、一条全额够扣时，对应条数的退与回就是满额写
            # 2、一条全额不够扣时，若有下一条，则本条部分写，下一条也部分写
            # 3、一条全额不够扣时，若无下一条，本条部分写
            # 上述三条中，2、3条合并写，因为没有下一条时，会跳出

            明细字典2['订单创建日期'] = 场次日期
            明细字典2['是否结算'] = 是否结算
            明细字典2['回款金额'] = 条数本金回款金额
            明细字典2['服务方'] = 服务方1
            明细字典2['资金方式'] = 资金方式1
            明细字典2['授信代码'] = 授信代码1

            if 回款节奏系数 != 1 :
                明细字典2['运营服务费'] = 0.00
                明细字典2['垫资服务费'] = 0.00
                明细字典2['贸易尾款'] = 0.00

            某一天明细 = pd.Series(明细字典2)
            某一天明细.name = 场次日期

            # 不断合并统计好的日期
            服务商账单核对表 = 服务商账单核对表.append(某一天明细)
            # 【每次while循环写入一条记录】写入本次总计按正常计算还是归0
            上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码最小值]) & 上次本金计费表['订单创建日期'].isin(
                [场次日期]), f'第{天数}天'] = 本次总计
            授信代码最小值 = 授信代码最小值 + 1
            # 进入本次循环代表使用过一条数据
            未结算条数 = 未结算条数 - 1

            # # 识别模块，未结算条数为0的情况的意思是本场次全部结算
            # if 未结算条数 == 0 and 是否计算完毕 == False:
            #     """"统计退本金用的是已回扣除，且是0.5，所以扣完后剩下的都是退本金，但是！！！很有可能扣不完或者扣多了"""
            #     完全结束场次字典.append(场次日期)

    # # 11.8 账单明细表订单创建日期排序，方便运营人员读取信息
    # 服务商账单核对表 = 服务商账单核对表.sort_values(by='订单创建日期',ascending=True)

    # 对本次结算的记录做处理
    for 被包裹字典 in 当天正常结算场次包裹型列表:
        for k, v in 被包裹字典.items():
            # k,v用于定位表格中的单元格
            当天结算场次 = k
            授信代码 = v
            # 写入理论结算日期
            上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                [当天结算场次]), '理论结算日期'] = 当天自然日

            # 只有资金方需要按月计费
            if 回款节奏系数 != 1 :
                # 添加当天自然日作为某场次的理论结算日期
                final_dataframe2 = 上次本金计费表[(上次本金计费表['订单创建日期'] == 当天结算场次) & (上次本金计费表['授信代码'] == 授信代码)]
                资金方式 = final_dataframe2.iloc[0].at['资金方式']
                # 写入理论结算日期
                上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin([当天结算场次]), '理论结算日期'] = 当天自然日

                使用天数求和 = 0
                for num in range(1, 41):
                    使用天数求和 = 使用天数求和 + final_dataframe2.iloc[0].at[f'第{num}天']

                总计授信 = final_dataframe2.iloc[0].at['总计授信']

                # 【金融计算模块】
                约定费率 = 0.02 / 30
                垫资费率 = 0.01 / 30
                理论费用 = round((总计授信 + 使用天数求和) * 约定费率, 2)
                垫资费用 = round((总计授信 + 使用天数求和) * 垫资费率, 2)  # 只有往来有，所以只写往来里

                上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                    [当天结算场次]), '理论应收服务费'] = 理论费用
                # 账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'理论应收服务费'] = float(理论费用)
                if 资金方式 == '贸易':
                    货款利润 = round(总计授信 * 0.01, 2)
                    上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                        [当天结算场次]), '贸易尾款'] = 货款利润
                    服务商账单核对表.loc[服务商账单核对表['订单创建日期'].isin([当天结算场次]) & 服务商账单核对表['授信代码'].isin(
                        [授信代码]), '贸易尾款'] = 货款利润
                    # 小于，则在返利处写入，大于则在服务费中写入
                    差额 = 理论费用 - 货款利润
                    if 差额 >= 0:
                        # 写总计费表
                        上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                            [当天结算场次]), '运营服务费'] = 差额
                        上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                            [当天结算场次]), '贸易返利'] = 0.00
                        # 写账单明细表
                        # 账单中的贸易返利不用写
                        服务商账单核对表.loc[服务商账单核对表['订单创建日期'].isin([当天结算场次]) & 服务商账单核对表['授信代码'].isin(
                            [授信代码]), '运营服务费'] = 差额

                    elif 差额 < 0:
                        # 写总计费表
                        上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                            [当天结算场次]), '贸易返利'] = abs(差额)
                        上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                            [当天结算场次]), '运营服务费'] = 0.00
                        # 写账单明细表
                        # 账单中的贸易返利不用写
                        # 账单中的运营服务费已经为0

                elif 资金方式 == '往来款':
                    运营往来费用 = 理论费用 - 垫资费用
                    上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                        [当天结算场次]), '运营服务费'] = 运营往来费用
                    上次本金计费表.loc[上次本金计费表['授信代码'].isin([授信代码]) & 上次本金计费表['订单创建日期'].isin(
                        [当天结算场次]), '垫资服务费'] = 垫资费用
                    服务商账单核对表.loc[服务商账单核对表['订单创建日期'].isin([当天结算场次]) & 服务商账单核对表['授信代码'].isin(
                        [授信代码]), '运营服务费'] = 运营往来费用
                    服务商账单核对表.loc[服务商账单核对表['订单创建日期'].isin([当天结算场次]) & 服务商账单核对表['授信代码'].isin(
                        [授信代码]), '垫资服务费'] = 垫资费用

    服务商账单核对表.index.name = '订单创建日期'
    if 回款节奏系数 != 1:
        服务商账单核对表 = 服务商账单核对表.loc[:,
                           ['订单创建日期', '服务方', '资金方式', '授信代码', '是否结算', '回款金额', '运营服务费',
                            '垫资服务费', '贸易尾款']]

    else:
        服务商账单核对表 = 服务商账单核对表.loc[:,
                           ['订单创建日期', '服务方', '资金方式', '授信代码', '是否结算', '回款金额']]



    return 上次本金计费表, 服务商账单核对表



from PySide2.QtWidgets import QApplication, QMessageBox, QFileDialog, QWidget
from ui_Fund_StatisticBill import Ui_Form


class Window(QWidget):

    def __init__(self):
        super().__init__()
        # 使用ui_Clean文件导入界面定义类
        self.ui = Ui_Form()
        self.ui.setupUi(self)  # 传入QWidget对象
        self.ui.retranslateUi(self)

        # 实例变量
        self.C_昨日计费表文件绝对路径 = ''
        self.C_中台文件夹绝对路径 = ''
        self.C_输出至文件夹 = ''
        self.C_操作人 = ''
        self.C_当天日期 = ''
        self.temp = ''  # 用于保存打开文件的路径

        self.ui.InputButton_1.clicked.connect(self.getInputFile)
        self.ui.InputButton_2.clicked.connect(self.getInputDir)
        self.ui.OutputButton.clicked.connect(self.getOutputDir)
        self.ui.RunButton.clicked.connect(self.handel)

    def getInputFile(self):
        self.temp, _ = QFileDialog.getOpenFileName(self, "选择昨日计费表", '', "Forms(*.xlsx *.csv)")
        if self.temp != '':
            self.C_昨日计费表文件绝对路径 = self.temp
            self.ui.InputFile.setText(self.C_昨日计费表文件绝对路径)

    def getInputDir(self):
        self.temp = QFileDialog.getExistingDirectory(self, "选择数据库相关文件夹路径")
        if self.temp != '':
            self.C_中台文件夹绝对路径 = self.temp
            self.ui.InputDir.setText(self.C_中台文件夹绝对路径)

    def getOutputDir(self):
        self.temp = QFileDialog.getExistingDirectory(self, "选择保存路径")  # 不使用本地对话框，可以查看文件夹内文件
        # self.temp = QFileDialog.getExistingDirectory(self, "选择保存路径")
        if self.temp != '':
            self.C_输出至文件夹 = self.temp
            self.ui.OutputDir.setText(self.C_输出至文件夹)

    def handel(self):

        self.C_操作人 = self.ui.User.text()
        self.C_当天日期 = self.ui.dateEdit.text()  # 本质是订单创建日期 格式：2022-01-30

        # 数据预处理
        try:
            日期格式 = datetime.datetime.strptime(f'{self.C_当天日期}', '%Y/%m/%d').strftime('%Y-%m-%d')
        except:
            日期格式 = self.C_当天日期

        # 打开与保存模块
        需打开表格名列表 = ['账单回款表']
        # 实例化对象,调用方法
        自动提取文件 = AutoExtractFiles(self.C_中台文件夹绝对路径, 需打开表格名列表)
        需打开表格字典 = 自动提取文件.handle()
        # 从文件名中提取相关信息
        文件名 = os.path.basename(需打开表格字典['账单回款表'])
        文件名前缀 = os.path.splitext(文件名)[0]
        平台类型 = 文件名前缀.split('-')[1]
        客户名称 = 文件名前缀.split('-')[0]
        # 打开需要的表格
        for k, v in 需打开表格字典.items():
            if k == '账单回款表':
                账单回款明细表 = pd.read_excel(v,sheet_name = '账单回款明细表')

        上次服务商本金计费表 = pd.read_excel(self.C_昨日计费表文件绝对路径, sheet_name='服务商本金计费表')
        上次资金方本金计费表 = pd.read_excel(self.C_昨日计费表文件绝对路径, sheet_name='资金方本金计费表')

        # 【例子】FOLA旗舰店-抖音-剩余金额表-2022-05-14
        输出文件名格式 = f'\\{客户名称}-{平台类型}-联合计费表-{日期格式}-{self.C_操作人}.xlsx'
        输出路径 = self.C_输出至文件夹 + 输出文件名格式

        # 下列函数种添加识别本场次的本金是否全部回完，如果回完则要让后面的函数知道且提取有关信息
        本次服务商本金计费表, 服务商账单核对表 = 本金计费表(上次服务商本金计费表,账单回款明细表,日期格式,1)  # 当天日期用于提取第N天
        print('第一步搞定')
        本次资金方本金计费表, 资金方账单核对表 = 本金计费表(上次资金方本金计费表,账单回款明细表,日期格式,0.7)  # 当天日期用于提取第N天
        print('第二步搞定')
        服务商账单核对表 = 服务商账单核对表.sort_index(ascending=True)
        资金方账单核对表 = 资金方账单核对表.sort_index(ascending=True)

        writer = pd.ExcelWriter(输出路径)
        本次服务商本金计费表.to_excel(writer, sheet_name='服务商本金计费表', index=False)

        本次资金方本金计费表.to_excel(writer, sheet_name='资金方本金计费表', index=False)

        服务商账单核对表.to_excel(writer, sheet_name='服务商账单核对表', index=False)

        资金方账单核对表.to_excel(writer, sheet_name='资金方账单核对表', index=False)

        writer.save()
        # 不用删掉，不然文件短时间内不能编辑，只能读取
        writer.close()

        # 成功后消息提醒
        QMessageBox.about(self, "处理结果", f'成功！\n请于“{self.C_输出至文件夹}”查看结果文件')


if __name__ == '__main__':
    app = QApplication([])
    window = Window()
    window.show()
    app.exec_()



