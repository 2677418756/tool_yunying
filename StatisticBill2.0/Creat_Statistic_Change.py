# -*- coding: utf-8 -*-
"""
Created on Tue May 17 10:39:14 2022

@author: Admin
"""


import pandas as pd
import datetime
import os
from collections import Counter
from PySide2.QtWidgets import QMessageBox

def str_to_date(str_):
    #【日期类型转换】让数据从str型转换成date型
    date_p = datetime.datetime.strptime(str_,'%Y-%m-%d').date()
    return date_p
def date_to_str(date_):
    #【日期类型转换】让数据从date型转换成str型
    return str(date_)

def timestamp_to_date(timestamp_):
    date = timestamp_.to_pydatetime().date()
    return date

def one_decimal(x_data):
    #【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.1f' % x_data #变成字符串来保留一位小数了
    return float(x_str)

def two_decimal(x_data):
    #【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.2f' % x_data #变成字符串来保留一位小数了
    return float(x_str)

class AutoExtractFiles():
    
    def __init__(self,文件夹路径,需打开表格名列表):      
        # 实例变量初始化
        self.输出字典 = {}
        self.文件夹路径 = 文件夹路径
        self.需打开表格名列表 = 需打开表格名列表       
        
    def handle(self):
        
        所有文件名列表 = os.listdir(self.文件夹路径)
        计数满足 = len(self.需打开表格名列表)
        
        for file in 所有文件名列表:
            #判断列表中元素是否存在，若存在则打开
            文件名前缀 = os.path.splitext(file)[0]
            表格类型 = 文件名前缀.split('-')[2]  #FOLA旗舰店-抖音-订单表-CJY-无备注.xlsx
            for need_workbook in self.需打开表格名列表:
                if 表格类型 == need_workbook:
                    #记录需打开的文件名，最后返回
                    计数满足 = 计数满足 - 1 #若所需文件全部都存在，则最后计数为0
                    temp = self.文件夹路径 + '\\' + file
                    self.输出字典[表格类型] = temp
                    
        return self.输出字典
    
    
def 抖音计费表(剩余金额表,退货退款表,账单回款表,订单金额表,当天自然日字符串,客户名称):
    

    
    #——————————————————————————————————————————————————————————————————————————————————特殊的变量
    店铺百分比字典 = {'FOLA旗舰店':{'销售退款率':0.5,'销售退货率':0.05},
           'XINGDAO STYLE':{'销售退款率':0.42,'销售退货率':0.14},'YIWEINUO':{'销售退款率':0.5,'销售退货率':0.05}
                      }
    店铺费率百分比字典 = {'FOLA旗舰店':{'2022-03-01':0.048,'2022-08-01':0.04},
       'XINGDAO STYLE':{'2022-03-01':0.048,'2022-08-01':0.04},'YIWEINUO':{'2022-08-20':0.04}}
    for k,v in 店铺百分比字典.items():
    
        if k == 客户名称:       
            预估销售退款率 = v['销售退款率']
            预估销售退货率 = v['销售退货率']
    #用最蠢的方法    
    for k,v in 店铺费率百分比字典.items():
        #v是一个字典，如{'2022-08-01':0.048}
        if k == 客户名称:       
            本次计费字典 = v
    预估店铺总退款率 = 预估销售退款率 + 预估销售退货率
    #截断日期用于不影响以前的店铺数据
    截断场次字符串 = '2022-08-01'
    截断场次日期 = datetime.datetime.strptime(截断场次字符串,'%Y-%m-%d').date()
    #——————————————————————————————————————————————————————————————————————————————————特殊的变量
    当天自然日 = datetime.datetime.strptime(当天自然日字符串,'%Y-%m-%d').date()
    
    剩余金额表['订单创建日期'] = 剩余金额表['订单创建日期'].map(timestamp_to_date)
    try:
        剩余金额表['理论结算日期'] = 剩余金额表['理论结算日期'].map(timestamp_to_date)
    except(AttributeError):
        #若没有已结算场次，则可能跳转到此语句
        pass
 
    退货退款表['订单创建日期'] = 退货退款表['订单创建日期'].map(str_to_date)
    账单回款表['订单创建日期'] = 账单回款表['订单创建日期'].map(str_to_date)
    订单金额表['订单创建日期'] = 订单金额表['订单创建日期'].map(str_to_date)
    #创建空白dataframe
    账单核对表 = pd.DataFrame()
    当天正常结算场次字典 = {}      
        
    未结算剩余金额表 = 剩余金额表[(剩余金额表['是否结算'] == '否')]
    list_ = list(未结算剩余金额表['订单创建日期'])
    
    #返回字典，统计列表中值出现的次数，可统计重复值，Key为原列表中的values
    未结算剩余金额字典 = Counter(list_)
    
    
    for k,v in 未结算剩余金额字典.items():
        未结算条数 = v
        场次日期 = k
        
        temp_dataframe0  = 未结算剩余金额表[(未结算剩余金额表['订单创建日期'] == 场次日期)]
        #下面两个本质是各自表中唯一的series
        temp_dataframe1  = 退货退款表[(退货退款表['订单创建日期'] == 场次日期)]
        temp_dataframe2  = 账单回款表[(账单回款表['订单创建日期'] == 场次日期)]  
           
        #【判断正确日期】如果当天自然日 - 场次日期 只计算大于1的自然日
        #计算时间差距的
        temp_time = 当天自然日 - 场次日期 
        天数 = temp_time.days + 1
        if 天数 <= 1 :
            #从第二天开始提取总金额 - 退 - 回 - 特殊
            print('需异常报错：输入当天自然日小于某场次日期')      
        #——————————————————————————————————————————————————————————————————读取数据模块
        try:
            场次退货退款金额 = temp_dataframe1.iloc[0].at[f'第{天数 - 1}天']
        except(IndexError):
            场次退货退款金额 = 0.00
        
        try:
            场次账单回款金额 = temp_dataframe2.iloc[0].at[f'第{天数 - 1}天']
        except(IndexError):
            场次账单回款金额 = 0.00
        
        
        
        #让数据保留一位小数，且自动四舍五入
        场次退货退款金额 = two_decimal(场次退货退款金额)
        场次账单回款金额 = two_decimal(场次账单回款金额)
        #——————————————————————————————————————————————————————————————————读取数据模块
        #——————————————————————————————————————————————————————————————————判断是否退款模块
        #读取对应场次的退货率+退款率
        if 场次日期 > 截断场次日期:
            场次销售退款率 = float(订单金额表.loc[订单金额表['订单创建日期'].isin([场次日期]),'退款率'])
            场次销售退货率 = float(订单金额表.loc[订单金额表['订单创建日期'].isin([场次日期]),'销售退货率'])
            场次总退款率 = round(场次销售退款率 + 场次销售退货率,2)
            if 场次总退款率 < 预估店铺总退款率:
                #当目前的退款率还没有超过预设的退款率时则不进行退款
                场次退货退款金额 = 0.00
        #——————————————————————————————————————————————————————————————————判断是否退款模块
    
        
        授信代码最小值 = temp_dataframe0['授信代码'].min() #min()返回series中的最小值,也就是返回授信代码这一列
        是否计算完毕 = True
        账单不足额跳转标志 = False
        中间值记录 = 0.00
        条数退货退款金额 = 场次退货退款金额
        条数账单回款金额 = 场次账单回款金额
        while 未结算条数 >= 1:
            
            #提取单独一条需要的记录，来提取数字
            final_dataframe1  = 未结算剩余金额表[(未结算剩余金额表['订单创建日期'] == 场次日期)&(未结算剩余金额表['授信代码'] == 授信代码最小值)]
            本次应统计金额 = final_dataframe1.iloc[0].at[f'第{天数}天']
            上次已统计金额 = final_dataframe1.iloc[0].at[f'第{天数 - 1}天']
            #【判断本次应统计金额需填入】本次应统计金额应该为0，也就是需要统计才对
            if not (本次应统计金额 == 0 and 上次已统计金额 != 0):
                print('异常警告：本次应统计金额或者上次已统计金额')
            
            #【将同场次下，没有改变总计的条数进行判断，并写入与跳过】
            if 未结算条数 != v and 是否计算完毕 == True:
                #未结算条数 != v 代表不是第一条记录，且计算完毕，所以上次总计等于本次总计
                print('同场其余未结算场次：',场次日期,授信代码最小值)
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 上次已统计金额
                授信代码最小值 = 授信代码最小值 + 1
                未结算条数 = 未结算条数 - 1
                continue #因为后面条数的本次应统计金额等于上次已统计金额，所以不用继续后面循环执行语句
            
            #【判断：选择总计的方法】
            if 是否计算完毕 == False:
                本次总计 = 上次已统计金额 - 中间值记录
            elif 是否计算完毕 == True :    
                本次总计 = 上次已统计金额 - 场次退货退款金额 - 场次账单回款金额
            #让数据保留一位小数，且自动四舍五入
            本次总计 = two_decimal(本次总计)
            
            #【判断：本条是否计算完毕】
            if 本次总计 <= 0.00:
                #若本次会结算，则本次总计填0，是否结算填是，账单表的值考虑改变
                #【判断后写入是否结算】写入要用剩余金额表，因为输出的也是剩余金额表
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),'是否结算'] = '是' #某条记录结算
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),'结算方式'] = '正常结算'
                当天正常结算场次字典[场次日期] = 授信代码最小值 #11.6发现不同同时记录同一场次不同授信代码，因为会覆盖VALUE值
                #影响多少用中间值记录
                中间值记录 = abs(本次总计)
                是否计算完毕 = False
                本次总计 = 0.00 
                
                #——————写账单模块
                #【本条记录不够扣，所以才需要改变账单的退与回】本条总计小于0，所以不够扣
                账单不足额跳转标志 = True
                条数账单回款金额 = 场次账单回款金额 - 中间值记录
                if 条数账单回款金额 < 0.00 :
                    #只有账单回款不够减了才会进入次判断语句
                    条数退货退款金额 = 场次退货退款金额 - abs(条数账单回款金额)
                    条数账单回款金额 = 0.00
                    
                #——————写账单模块  
                
            elif 本次总计 > 0.00:
                if 账单不足额跳转标志 == True:
                    if 条数账单回款金额 == 0.00:
                        #【只有上一条不够扣，且有本条时才会进入本判断】当账单回款金额不够减，还减去了退货退款
                        条数退货退款金额 = 场次退货退款金额 - 条数退货退款金额
                        条数账单回款金额 = 场次账单回款金额
                    elif 条数账单回款金额 > 0.00:
                        条数账单回款金额 = 场次账单回款金额 - 条数账单回款金额 #本条回款金额等于总回款金额减去上一条输出的回款金额
                        条数退货退款金额 = 0.00  #当上一条记录的账单回款金额没被扣完时，不会影响上一条的退款金额
                    
                中间值记录 = 0.00
                是否计算完毕 = True           
            #——————提取其他相关信息
            服务方1 = final_dataframe1.iloc[0].at['服务方']
            资金方式1 = final_dataframe1.iloc[0].at['资金方式']
            授信代码1 =  授信代码最小值
            
            #——————提取其他相关信息
            
            #1、一条全额够扣时，对应条数的退与回就是满额写
            #2、一条全额不够扣时，若有下一条，则本条部分写，下一条也部分写
            #3、一条全额不够扣时，若无下一条，本条部分写
            #上述三条中，2、3条合并写，因为没有下一条时，会跳出
            
            #【每一个while条数，只有改变的同场异次，循环写入一次】写账单明细表
            明细字典2 = {}
            明细字典2['订单创建日期'] = 场次日期
            明细字典2['退货退款'] =  条数退货退款金额
            明细字典2['账单回款'] = 条数账单回款金额
            明细字典2['运营服务费'] = 0.00
            明细字典2['垫资服务费'] = 0.00
            明细字典2['贸易尾款'] = 0.00
            明细字典2['服务方'] = 服务方1
            明细字典2['资金方式'] = 资金方式1
            明细字典2['授信代码'] = 授信代码1
            某一天明细 = pd.Series(明细字典2)
            某一天明细.name = 场次日期
            
            #不断合并统计好的日期
            账单核对表 = 账单核对表.append(某一天明细)
            #【每次while循环写入一条记录】写入本次总计按正常计算还是归0  
            剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 本次总计
            授信代码最小值 = 授信代码最小值 + 1
            #进入本次循环代表使用过一条数据
            未结算条数 = 未结算条数 - 1
            
        
    账单核对表.index.name='订单创建日期'
    #改变列的序列
    账单核对表 = 账单核对表.loc[:,['订单创建日期','服务方','资金方式','授信代码','退货退款','账单回款','运营服务费','垫资服务费','贸易尾款']]
    

    # print('当天结算场次以及对应授信代码：\n',当天正常结算场次字典)
    for k,v in 当天正常结算场次字典.items():
        #k,v用于定位表格中的单元格
        当天结算场次 = k
        授信代码 = v
        #添加当天自然日作为某场次的理论结算日期
        final_dataframe2  = 剩余金额表[(剩余金额表['订单创建日期'] == 当天结算场次)&(剩余金额表['授信代码'] == 授信代码)]
        资金方式 = final_dataframe2.iloc[0].at['资金方式']
        #写入理论结算日期
        剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'理论结算日期'] = 当天自然日
               
        使用天数求和 = 0
        for num in range(1,41):
            使用天数求和 = 使用天数求和 + final_dataframe2.iloc[0].at[f'第{num}天']     
            
        总计授信 = final_dataframe2.iloc[0].at['总计授信']
        
        #【金融计算模块】
        中间记录差值 = -1
        for k,v in 本次计费字典.items():
            #k为字符串日期，v为费率
            #用当前日期 - 字典提取日期比较，只选择使用比值大于零且最小的那个参数
            使用场次日期 = datetime.datetime.strptime(k,'%Y-%m-%d').date()
            if (当天结算场次 - 使用场次日期).days >= 0:
                差值 = (当天结算场次 - 使用场次日期).days
                if 差值 < 中间记录差值 or 中间记录差值 < 0:
                    中间记录差值 = 差值
                    约定费率 = v/30
        # 约定费率 = 0.0016
        垫资费率 = 0.01/30
        理论费用 = round((总计授信 + 使用天数求和)*约定费率,2)
        垫资费用 = round((总计授信 + 使用天数求和)*垫资费率,2) #只有往来有，所以只写往来里
        
        
        剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'理论应收服务费'] = 理论费用
        # 账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'理论应收服务费'] = float(理论费用)
        if 资金方式 == '货款':
            货款利润 = round(总计授信*0.01,2)
            剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'贸易尾款'] = 货款利润
            账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'贸易尾款'] = 货款利润
            #小于，则在返利处写入，大于则在服务费中写入
            差额 = 理论费用 - 货款利润
            if 差额 >= 0:
                #写总计费表
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'运营服务费'] = 差额
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'贸易返利'] = 0.00
                #写账单明细表
                #账单中的贸易返利不用写
                账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'运营服务费'] = 差额

            elif 差额 < 0:
                #写总计费表
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'贸易返利'] = abs(差额)
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'运营服务费'] = 0.00
                #写账单明细表
                #账单中的贸易返利不用写
                #账单中的运营服务费已经为0
                
        elif 资金方式 == '往来款':
            运营往来费用 = 理论费用 - 垫资费用
            剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'运营服务费'] = 运营往来费用
            剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'垫资服务费'] = 垫资费用
            账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'运营服务费'] = 运营往来费用
            账单核对表.loc[账单核对表['订单创建日期'].isin([当天结算场次])&账单核对表['授信代码'].isin([授信代码]),'垫资服务费'] = 垫资费用
            
    return 剩余金额表,账单核对表
        



class Create:

    def __init__(self, orderpath, costpath, outputdir, user, date):
        #————————————————————————————————————————————————————————————————————用户输入模块
        self.C_昨日计费表文件绝对路径 = orderpath
        self.C_中台文件夹绝对路径 = costpath
        self.C_输出至文件夹 = outputdir
        self.C_操作人 = user
        self.C_当天日期 = date #本质是订单创建日期 格式：2022-01-30
        #————————————————————————————————————————————————————————————————————用户输入模块

        
    def create(self, Form):

        

        #数据预处理
        try:
            日期格式 = datetime.datetime.strptime(f'{self.C_当天日期}','%Y/%m/%d').strftime('%Y-%m-%d')
        except:
            日期格式 = self.C_当天日期

        
        # 打开与保存模块
        需打开表格名列表 = ['退货退款表','账单回款表','订单金额表']
        # 实例化对象,调用方法
        自动提取文件 = AutoExtractFiles(self.C_中台文件夹绝对路径,需打开表格名列表)
        需打开表格字典 = 自动提取文件.handle()
        # 从文件名中提取相关信息
        文件名 = os.path.basename(需打开表格字典['退货退款表']) # FOLA旗舰店-抖音-退货退款表-CJY-2022-05-14.xlsx
        文件名前缀 = os.path.splitext(文件名)[0] # FOLA旗舰店-抖音-退货退款表-CJY-2022-05-14
        平台类型 = 文件名前缀.split('-')[1] # FOLA旗舰店-【抖音】-退货退款表-CJY-2022-05-14
        客户名称 = 文件名前缀.split('-')[0] # 【FOLA旗舰店】-抖音-退货退款表-CJY-2022-05-14
        # 打开需要的表格
        for k,v in 需打开表格字典.items():
            if k == '退货退款表':
                今日退货退款表 = pd.read_excel(v)
            elif k == '账单回款表':
                今日账单回款表 = pd.read_excel(v)
            elif k == '订单金额表':
                今日订单金额表 = pd.read_excel(v)
        昨日剩余金额表 = pd.read_excel(self.C_昨日计费表文件绝对路径)
        
        
        #【例子】FOLA旗舰店-抖音-剩余金额表-2022-05-14
        输出文件名格式 = f'\\{客户名称}-{平台类型}-计费表-{日期格式}-{self.C_操作人}.xlsx'
        输出路径 = self.C_输出至文件夹 + 输出文件名格式


        已统计剩余金额表,账单明细表 = 抖音计费表(昨日剩余金额表,今日退货退款表,今日账单回款表,今日订单金额表,日期格式,客户名称)


        # 已统计剩余金额表.to_excel(输出路径,index=False)


        #【writer】使用writer将dataframe放入不同的excel的sheet中
        #使用pd.ExcelWriter
        writer = pd.ExcelWriter(输出路径)
        已统计剩余金额表.to_excel(writer, sheet_name=f'{日期格式}剩余金额表',index=False)
        账单明细表.to_excel(writer, sheet_name=f'{日期格式}账单明细表',index=False)
        writer.save()
        #不用删掉，不然文件短时间内不能编辑，只能读取
        writer.close()
        
        #成功后消息提醒
        QMessageBox.about(Form, "处理结果", f'成功！\n请于“{self.C_输出至文件夹}”查看结果文件')