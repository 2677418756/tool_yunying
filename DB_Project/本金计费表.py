# -*- coding: utf-8 -*-
"""
Created on Thu Oct  6 18:18:12 2022

@author: Wind_Aleady_Here
"""

import pandas as pd
import datetime
import os
from collections import Counter
# 本金计费表的业务逻辑

"""
需要的数据来源：上一次本金计费表、本次的订单回款表
业务逻辑：读取

核心解决的的问题：
待解决的问题：
备注：
"""
def str_to_date(str_):
    #【日期类型转换】让数据从str型转换成date型
    date_p = datetime.datetime.strptime(str_,'%Y-%m-%d').date()
    return date_p
def date_to_str(date_):
    #【日期类型转换】让数据从date型转换成str型
    return str(date_)

def timestamp_to_date(timestamp_):
    date = timestamp_.to_pydatetime().date()
    return date

def one_decimal(x_data):
    #【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.1f' % x_data #变成字符串来保留一位小数了
    return float(x_str)

def two_decimal(x_data):
    #【浮点数先转字符串，再转浮点数】让数据保留一位小数，且自动四舍五入
    x_str = '%.2f' % x_data #变成字符串来保留一位小数了
    return float(x_str)

class AutoExtractFiles():
    
    def __init__(self,文件夹路径,需打开表格名列表):      
        # 实例变量初始化
        self.输出字典 = {}
        self.文件夹路径 = 文件夹路径
        self.需打开表格名列表 = 需打开表格名列表       
        
    def handle(self):
        
        所有文件名列表 = os.listdir(self.文件夹路径)
        计数满足 = len(self.需打开表格名列表)
        
        for file in 所有文件名列表:
            #判断列表中元素是否存在，若存在则打开
            文件名前缀 = os.path.splitext(file)[0]
            表格类型 = 文件名前缀.split('-')[2]  #FOLA旗舰店-抖音-订单表-CJY-无备注.xlsx
            for need_workbook in self.需打开表格名列表:
                if 表格类型 == need_workbook:
                    #记录需打开的文件名，最后返回
                    计数满足 = 计数满足 - 1 #若所需文件全部都存在，则最后计数为0
                    temp = self.文件夹路径 + '\\' + file
                    self.输出字典[表格类型] = temp
                    
        return self.输出字典
    
    
def 本金计费表(剩余金额表,结算回款表,当天自然日字符串):
    
    当天自然日 = datetime.datetime.strptime(当天自然日字符串,'%Y-%m-%d').date()
    
    剩余金额表['订单创建日期'] = 剩余金额表['订单创建日期'].map(timestamp_to_date)
    try:
        剩余金额表['理论结算日期'] = 剩余金额表['理论结算日期'].map(timestamp_to_date)
    except(AttributeError):
        #若没有已结算场次，则可能跳转到此语句
        pass
 
    结算回款表['订单创建日期'] = 结算回款表['订单创建日期'].map(str_to_date)
    
    #创建空白dataframe
    账单核对表 = pd.DataFrame()
    当天正常结算场次字典 = {}      
        
    未结算剩余金额表 = 剩余金额表[(剩余金额表['是否结算'] == '否')]
    list_ = list(未结算剩余金额表['订单创建日期'])
    
    #返回字典，统计列表中值出现的次数，可统计重复值，Key为原列表中的values
    未结算剩余金额字典 = Counter(list_)

    
    for k,v in 未结算剩余金额字典.items():
        """
        按场次进行大循环，场次内的记录条数做小循环
        """
        未结算条数 = v
        场次日期 = k
        
        temp_dataframe0  = 未结算剩余金额表[(未结算剩余金额表['订单创建日期'] == 场次日期)]
        #下面两个本质是各自表中唯一的series
        temp_dataframe2  = 结算回款表[(结算回款表['订单创建日期'] == 场次日期)]  
           
        #【判断正确日期】如果当天自然日 - 场次日期 只计算大于1的自然日
        #计算时间差距的
        temp_time = 当天自然日 - 场次日期 
        天数 = temp_time.days + 1
        if 天数 <= 1 :
            #从第二天开始提取总金额 - 退 - 回 - 特殊
            print('需异常报错：输入当天自然日小于某场次日期')      
        #——————————————————————————————————————————————————————————————————读取数据模块
        
        try:
            场次本金回款金额 = temp_dataframe2.iloc[0].at[f'第{天数 - 1}天']
        except(IndexError):
            场次本金回款金额 = 0.00


        #让数据保留一位小数，且自动四舍五入
        场次本金回款金额 = two_decimal(场次本金回款金额)
        #——————————————————————————————————————————————————————————————————读取数据模块

        
        授信代码最小值 = temp_dataframe0['授信代码'].min() #min()返回series中的最小值,也就是返回授信代码这一列
        是否计算完毕 = True # 这里的逻辑可以理解为 相信第一次就能计算完毕，所以填True
        中间值记录 = 0.00
        # 条数退货退款金额 = 场次退货退款金额
        条数本金回款金额 = 场次本金回款金额
        while 未结算条数 >= 1:
            
            #提取单独一条需要的记录，来提取数字
            final_dataframe1  = 未结算剩余金额表[(未结算剩余金额表['订单创建日期'] == 场次日期)&(未结算剩余金额表['授信代码'] == 授信代码最小值)]
            本次应统计金额 = final_dataframe1.iloc[0].at[f'第{天数}天']
            上次已统计金额 = final_dataframe1.iloc[0].at[f'第{天数 - 1}天']
            #【判断本次应统计金额需填入】本次应统计金额应该为0，也就是需要统计才对
            if not (本次应统计金额 == 0 and 上次已统计金额 != 0):
                print('异常警告：本次应统计金额或者上次已统计金额')
            
            #【将同场次下，没有改变总计的条数进行判断，并写入与跳过】
            if 未结算条数 != v and 是否计算完毕 == True:
                #未结算条数 != v 代表不是第一条记录，且计算完毕，所以上次总计等于本次总计
                print('同场其余未结算场次：',场次日期,授信代码最小值)
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 上次已统计金额
                授信代码最小值 = 授信代码最小值 + 1
                未结算条数 = 未结算条数 - 1
                continue #因为后面条数的本次应统计金额等于上次已统计金额，所以不用继续后面循环执行语句
            
            #【判断：选择总计的方法】
            if 是否计算完毕 == False:
                本次总计 = 上次已统计金额 - 中间值记录
            elif 是否计算完毕 == True :
                # 第一次循环先走本条语句，因为前面设置为True了
                本次总计 = 上次已统计金额 - 场次本金回款金额
            #让数据保留一位小数，且自动四舍五入
            本次总计 = two_decimal(本次总计)
            
            #【判断：本条是否计算完毕】
            if 本次总计 <= 0.00:
                #若本次会结算，则本次总计填0，是否结算填是，账单表的值考虑改变
                #【判断后写入是否结算】写入要用剩余金额表，因为输出的也是剩余金额表
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),'是否结算'] = '是' #某条记录结算
                剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),'结算方式'] = '正常结算'
                当天正常结算场次字典[场次日期] = 授信代码最小值
                #影响多少用中间值记录
                中间值记录 = abs(本次总计)
                是否计算完毕 = False
                本次总计 = 0.00 
                # 本条记录对应的 回款金额
                条数本金回款金额 = 场次本金回款金额 - 中间值记录

                
            elif 本次总计 > 0.00:
                中间值记录 = 0.00
                是否计算完毕 = True           
                
            #——————提取其他相关信息
            服务方1 = final_dataframe1.iloc[0].at['服务方']
            资金方式1 = final_dataframe1.iloc[0].at['资金方式']
            授信代码1 =  授信代码最小值
            
            #——————提取其他相关信息
            
            #1、一条全额够扣时，对应条数的退与回就是满额写
            #2、一条全额不够扣时，若有下一条，则本条部分写，下一条也部分写
            #3、一条全额不够扣时，若无下一条，本条部分写
            #上述三条中，2、3条合并写，因为没有下一条时，会跳出
            
            #【每一个while条数，只有改变的同场异次，循环写入一次】写账单明细表
            明细字典2 = {}
            明细字典2['订单创建日期'] = 场次日期
            明细字典2['回款金额'] = 条数本金回款金额
            明细字典2['服务方'] = 服务方1
            明细字典2['资金方式'] = 资金方式1
            明细字典2['授信代码'] = 授信代码1
            某一天明细 = pd.Series(明细字典2)
            某一天明细.name = 场次日期
            
            #不断合并统计好的日期
            账单核对表 = 账单核对表.append(某一天明细)
            #【每次while循环写入一条记录】写入本次总计按正常计算还是归0  
            剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码最小值])&剩余金额表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 本次总计
            授信代码最小值 = 授信代码最小值 + 1
            #进入本次循环代表使用过一条数据
            未结算条数 = 未结算条数 - 1
            
            # # 识别模块，未结算条数为0的情况的意思是本场次全部结算
            # if 未结算条数 == 0 and 是否计算完毕 == False:
            #     """"统计退本金用的是已回扣除，且是0.5，所以扣完后剩下的都是退本金，但是！！！很有可能扣不完或者扣多了"""
            #     完全结束场次字典.append(场次日期)
             
            
        
    账单核对表.index.name='订单创建日期'
    #改变列的序列
    账单核对表 = 账单核对表.loc[:,['订单创建日期','服务方','资金方式','授信代码','本金回款']]

    # 对本次结算的记录做处理
    for k,v in 当天正常结算场次字典.items():
        #k,v用于定位表格中的单元格
        当天结算场次 = k
        授信代码 = v
        #写入理论结算日期
        剩余金额表.loc[剩余金额表['授信代码'].isin([授信代码])&剩余金额表['订单创建日期'].isin([当天结算场次]),'理论结算日期'] = 当天自然日


    return 剩余金额表,账单核对表,当天正常结算场次字典



def 退本金统计表(退本金统计表,本金回款表,当天自然日字符串,当天正常结算场次字典):
    
    当天自然日 = datetime.datetime.strptime(当天自然日字符串,'%Y-%m-%d').date()
    
    退本金统计表['订单创建日期'] = 退本金统计表['订单创建日期'].map(timestamp_to_date)
    退本金统计表['授信日期'] = 退本金统计表['授信日期'].map(timestamp_to_date)
    try:
        退本金统计表['理论结算日期'] = 退本金统计表['理论结算日期'].map(timestamp_to_date)
    except(AttributeError):
        #若没有已结算场次，则可能跳转到此语句
        pass
    本金回款表['订单创建日期'] = 本金回款表['订单创建日期'].map(str_to_date)
    
    # 创建空白dataframe
    退本金核对表 = pd.DataFrame()
    # # 循环筛选出结束场次，对该场次进行处理和统计
    for k,v in 当天正常结算场次字典.items():
        #k,v用于定位表格中的单元格
        当天结算场次 = k
        授信代码 = v
        
        #筛选
        enddataframe  = 退本金统计表[(退本金统计表['订单创建日期'] == 当天结算场次)&(退本金统计表['授信代码'] == 授信代码)]
        # 获取从左到右第一个不为零的列名来获取首次授信对应日期
        授信日期 = enddataframe.iloc[0].at['授信日期']
        
        #计算时间差距的
        temp_time1 = 当天自然日 - 当天结算场次 
        结束天数 = temp_time1.days # 不加1则是上次统计金额
        temp_time2 = 当天自然日 - 授信日期
        开始天数 = temp_time2.days
        
        # 不做“上次金额=本次金额”处理，直接统计上次金额对应列的求和，并将结算标志改为是，并输出到核对表
        总退本金 = enddataframe[f'第{结束天数}天'].sum()
        退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码])&退本金统计表['订单创建日期'].isin([当天结算场次]),'是否结算'] = '是' #某条记录结算
        退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码])&退本金统计表['订单创建日期'].isin([当天结算场次]),'结算方式'] = '正常结算'           
        #输出到退本金核对表
        明细字典2 = {}
        明细字典2['订单创建日期'] = 当天结算场次
        明细字典2['总退本金'] = 总退本金
        明细字典2['使用天数'] = int(结束天数 - 开始天数 + 1)
        
        某一天明细 = pd.Series(明细字典2)
        某一天明细.name = 当天结算场次
        
        #不断合并统计好的日期
        退本金核对表 = 退本金核对表.append(某一天明细)
        退本金核对表.index.name='订单创建日期'
        #改变列的序列
        退本金核对表 = 退本金核对表.loc[:,['订单创建日期','总退本金','使用天数']]
    
    
    当天正常结算场次字典 = {}      
        
    未结算退本金统计表 = 退本金统计表[(退本金统计表['是否结算'] == '否')]
    list_ = list(未结算退本金统计表['订单创建日期'])
    
    #返回字典，统计列表中值出现的次数，可统计重复值，Key为原列表中的values
    未结算剩余金额字典 = Counter(list_)
    
    for k,v in 未结算剩余金额字典.items():
        """
        按场次进行大循环，场次内的记录条数做小循环
        """
        未结算条数 = v
        场次日期 = k
        
        temp_dataframe0  = 未结算退本金统计表[(未结算退本金统计表['订单创建日期'] == 场次日期)]
        #下面两个本质是各自表中唯一的series
        temp_dataframe2  = 本金回款表[(本金回款表['订单创建日期'] == 场次日期)]  
           
        #【判断正确日期】如果当天自然日 - 场次日期 只计算大于1的自然日
        #计算时间差距的
        temp_time = 当天自然日 - 场次日期 
        天数 = temp_time.days + 1
        if 天数 <= 1 :
            #从第二天开始提取总金额 - 退 - 回 - 特殊
            print('需异常报错：输入当天自然日小于某场次日期')      
        #——————————————————————————————————————————————————————————————————读取数据模块
        
        try:
            场次本金回款金额 = temp_dataframe2.iloc[0].at[f'第{天数 - 1}天']
        except(IndexError):
            场次本金回款金额 = 0.00


        #让数据保留一位小数，且自动四舍五入
        场次本金回款金额 = two_decimal(场次本金回款金额)
        #——————————————————————————————————————————————————————————————————读取数据模块

        
        授信代码最小值 = temp_dataframe0['授信代码'].min() #min()返回series中的最小值,也就是返回授信代码这一列
        是否计算完毕 = True # 这里的逻辑可以理解为 相信第一次就能计算完毕，所以填True
        中间值记录 = 0.00
        # 条数退货退款金额 = 场次退货退款金额
        条数本金回款金额 = 场次本金回款金额
        while 未结算条数 >= 1:
            
            #提取单独一条需要的记录，来提取数字
            final_dataframe1  = 未结算退本金统计表[(未结算退本金统计表['订单创建日期'] == 场次日期)&(未结算退本金统计表['授信代码'] == 授信代码最小值)]
            本次应统计金额 = final_dataframe1.iloc[0].at[f'第{天数}天']
            上次已统计金额 = final_dataframe1.iloc[0].at[f'第{天数 - 1}天']
            #【判断本次应统计金额需填入】本次应统计金额应该为0，也就是需要统计才对
            if not (本次应统计金额 == 0 and 上次已统计金额 != 0):
                print('异常警告：本次应统计金额或者上次已统计金额')
            
            #【将同场次下，没有改变总计的条数进行判断，并写入与跳过】
            if 未结算条数 != v and 是否计算完毕 == True:
                #未结算条数 != v 代表不是第一条记录，且计算完毕，所以上次总计等于本次总计
                print('同场其余未结算场次：',场次日期,授信代码最小值)
                退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码最小值])&退本金统计表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 上次已统计金额
                授信代码最小值 = 授信代码最小值 + 1
                未结算条数 = 未结算条数 - 1
                continue #因为后面条数的本次应统计金额等于上次已统计金额，所以不用继续后面循环执行语句
            
            #【判断：选择总计的方法】
            if 是否计算完毕 == False:
                本次总计 = 上次已统计金额 - 中间值记录
            elif 是否计算完毕 == True :
                # 第一次循环先走本条语句，因为前面设置为True了
                本次总计 = 上次已统计金额 - 场次本金回款金额
            #让数据保留一位小数，且自动四舍五入
            本次总计 = two_decimal(本次总计)
            
            #【判断：本条是否计算完毕】
            if 本次总计 <= 0.00:
                #若本次会结算，则本次总计填0，是否结算填是，账单表的值考虑改变
                #【判断后写入是否结算】写入要用退本金统计表，因为输出的也是退本金统计表
                退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码最小值])&退本金统计表['订单创建日期'].isin([场次日期]),'是否结算'] = '是' #某条记录结算
                退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码最小值])&退本金统计表['订单创建日期'].isin([场次日期]),'结算方式'] = '正常结算'
                当天正常结算场次字典[场次日期] = 授信代码最小值
                #影响多少用中间值记录
                中间值记录 = abs(本次总计)
                是否计算完毕 = False
                本次总计 = 0.00
                # 本条记录对应的 回款金额
                条数本金回款金额 = 场次本金回款金额 - 中间值记录
                
            elif 本次总计 > 0.00:
                中间值记录 = 0.00
                是否计算完毕 = True           
                

            #【每次while循环写入一条记录】写入本次总计按正常计算还是归0  
            退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码最小值])&退本金统计表['订单创建日期'].isin([场次日期]),f'第{天数}天'] = 本次总计
            授信代码最小值 = 授信代码最小值 + 1
            #进入本次循环代表使用过一条数据
            未结算条数 = 未结算条数 - 1
            
        


    # 对本次结算的记录做处理
    for k,v in 当天正常结算场次字典.items():
        #k,v用于定位表格中的单元格
        当天结算场次 = k
        授信代码 = v
        #写入理论结算日期
        退本金统计表.loc[退本金统计表['授信代码'].isin([授信代码])&退本金统计表['订单创建日期'].isin([当天结算场次]),'理论结算日期'] = 当天自然日


    return 退本金统计表,退本金核对表

#读取文件
上次剩余金额表 = pd.read_excel(r'C:\Users\Admin\Desktop\本金计费测试\TB-快手-计费表-2022-10-07-GYH.xlsx',sheet_name = '2022-10-07剩余金额表')
上次退本金表 = pd.read_excel(r'C:\Users\Admin\Desktop\本金计费测试\TB-快手-计费表-2022-10-07-GYH.xlsx',sheet_name = '2022-10-07退本金统计表')

本金明细表 = pd.read_excel(r'C:\Users\Admin\Desktop\本金计费测试\黄金-订单回款表-GYH.xlsx',sheet_name = '本金明细表')
结算金额明细表 = pd.read_excel(r'C:\Users\Admin\Desktop\本金计费测试\黄金-订单回款表-GYH.xlsx',sheet_name = '结算金额明细表')

# 下列函数种添加识别本场次的本金是否全部回完，如果回完则要让后面的函数知道且提取有关信息
本次剩余金额表,账单核对表,当天正常结算场次字典 = 本金计费表(上次剩余金额表,结算金额明细表,'2022-02-01') #当天日期用于提取第N天

本次退本金表,退本金核对表 = 退本金统计表(上次退本金表,本金明细表,'2022-02-01',当天正常结算场次字典)

输出路径 = r'C:\Users\Admin\Desktop\本金计费测试\测试结果.xlsx'

writer = pd.ExcelWriter(输出路径)
本次剩余金额表.to_excel(writer, sheet_name='本次剩余金额表',index=False)

本次退本金表.to_excel(writer, sheet_name='本次退本金表',index=False)

账单核对表.to_excel(writer, sheet_name='账单核对表',index=False)

退本金核对表.to_excel(writer, sheet_name='退本金核对表',index=False)

writer.save()
#不用删掉，不然文件短时间内不能编辑，只能读取
writer.close()




